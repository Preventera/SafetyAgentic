# Agent R1 - G√©n√©rateur Recommandations SafetyAgentic
# ===================================================
# Transforme zones aveugles AN1 en plan d'action concret
# Bas√© sur meilleures pratiques HSE et donn√©es CNESST

import asyncio
from typing import Dict, List, Tuple, Optional
import json
import logging
from datetime import datetime, timedelta
import numpy as np

# Configuration logger
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("SafetyAgentic.R1")

class R1GenerateurRecommandations:
    """
    Agent R1 - G√©n√©rateur de Recommandations
    
    Fonctions principales:
    1. Analyser zones aveugles AN1 et contexte incident
    2. G√©n√©rer recommandations sp√©cifiques par zone aveugle
    3. Cr√©er plan d'action structur√© avec priorit√©s
    4. Calculer ressources, budgets et ROI estim√©s
    5. Adapter recommandations selon secteur SCIAN
    6. Int√©grer meilleures pratiques HSE sectorielles
    """
    
    def __init__(self):
        """Initialisation Agent R1"""
        self.agent_id = "R1"
        self.agent_name = "G√©n√©rateur Recommandations"
        self.version = "1.0.0"
        
        # Base de connaissances recommandations par variable
        self.recommandations_db = {
            "usage_epi": {
                "formations": [
                    "Formation pratique port EPI obligatoire",
                    "Sensibilisation risques sp√©cifiques poste",
                    "D√©monstration √©quipements protection"
                ],
                "procedures": [
                    "Check-list quotidienne EPI par poste",
                    "Contr√¥les visuels superviseurs",
                    "Sanctions progressives non-conformit√©"
                ],
                "equipements": [
                    "Audit qualit√© EPI fournis",
                    "Remplacement √©quipements d√©faillants",
                    "Test confort et ergonomie EPI"
                ],
                "budget_unitaire": 150,  # $ par employ√©
                "duree_formation": 4     # heures
            },
            
            "supervision_directe": {
                "formations": [
                    "Formation supervision s√©curit√© superviseurs",
                    "Techniques communication risques",
                    "Leadership s√©curit√© terrain"
                ],
                "procedures": [
                    "Rondes s√©curit√© obligatoires (2x/jour)",
                    "Check-lists supervision standardis√©es",
                    "Reporting hebdomadaire s√©curit√©"
                ],
                "organisationnel": [
                    "D√©finir ratio superviseur/employ√© optimal",
                    "R√©organiser planning supervision",
                    "Syst√®me reconnaissance supervision exemplaire"
                ],
                "budget_unitaire": 800,
                "duree_formation": 16
            },
            
            "formation_securite": {
                "formations": [
                    "Mise √† jour formations s√©curit√© sectorielles",
                    "Certifications obligatoires par poste",
                    "Recyclage annuel competences s√©curit√©"
                ],
                "procedures": [
                    "Matrice comp√©tences s√©curit√© par poste",
                    "√âvaluation pratique post-formation",
                    "Suivi continu acquisitions comp√©tences"
                ],
                "pedagogique": [
                    "Supports formation interactifs",
                    "Simulations incidents sectoriels",
                    "Mentorat s√©curit√© senior/junior"
                ],
                "budget_unitaire": 400,
                "duree_formation": 8
            },
            
            "communication_risques": {
                "formations": [
                    "Formation communication risques efficace",
                    "Techniques feedback s√©curit√©",
                    "Animation toolbox meetings"
                ],
                "procedures": [
                    "Meetings s√©curit√© hebdomadaires obligatoires",
                    "Syst√®me remont√©e incidents/presqu'accidents",
                    "Affichage risques sp√©cifiques postes"
                ],
                "organisationnel": [
                    "Nomination r√©f√©rents s√©curit√© par √©quipe",
                    "Bo√Æte √† id√©es am√©lioration s√©curit√©",
                    "Feedback loop management/terrain"
                ],
                "budget_unitaire": 200,
                "duree_formation": 6
            },
            
            "leadership_sst": {
                "formations": [
                    "Leadership s√©curit√© pour managers",
                    "Excellence op√©rationnelle et s√©curit√©",
                    "Culture s√©curit√© haute performance"
                ],
                "procedures": [
                    "Engagement visible leadership terrain",
                    "Objectifs s√©curit√© dans √©valuations",
                    "Reconnaissance comportements s√©curitaires"
                ],
                "strategique": [
                    "Politique s√©curit√© renforc√©e direction",
                    "Investissements s√©curit√© prioritaires",
                    "Certification management s√©curit√©"
                ],
                "budget_unitaire": 1200,
                "duree_formation": 24
            },
            
            "respect_procedures": {
                "formations": [
                    "Formation proc√©dures s√©curit√© sp√©cifiques",
                    "Importance respect consignes",
                    "Cons√©quences non-conformit√©s"
                ],
                "procedures": [
                    "Simplification proc√©dures complexes",
                    "Audit conformit√© proc√©dures mensuel",
                    "Syst√®me suggestions am√©lioration"
                ],
                "organisationnel": [
                    "R√©vision proc√©dures obsol√®tes",
                    "Co-construction proc√©dures avec terrain",
                    "Digitalisation check-lists terrain"
                ],
                "budget_unitaire": 300,
                "duree_formation": 6
            }
        }
        
        # Facteurs sectoriels SCIAN
        self.facteurs_sectoriels = {
            "CONSTRUCTION": {
                "multiplicateur_budget": 1.3,
                "duree_implementation": 1.2,
                "priorites_specifiques": ["hauteur", "machines_lourdes", "coordination_equipes"],
                "regulations": ["CSTC", "CCQ", "CSST"]
            },
            "SOINS_SANTE": {
                "multiplicateur_budget": 0.9,
                "duree_implementation": 0.8,
                "priorites_specifiques": ["infections", "manutention_patients", "produits_chimiques"],
                "regulations": ["MSSS", "OIQ", "OIIQ"]
            },
            "FABRICATION": {
                "multiplicateur_budget": 1.1,
                "duree_implementation": 1.0,
                "priorites_specifiques": ["machines_production", "produits_chimiques", "bruit"],
                "regulations": ["CNESST", "MAPAQ", "ECCC"]
            },
            "TRANSPORT": {
                "multiplicateur_budget": 1.0,
                "duree_implementation": 0.9,
                "priorites_specifiques": ["fatigue", "conduite_defensive", "manutention"],
                "regulations": ["MTQ", "TC", "SAAQ"]
            }
        }
        
        # Templates d'actions par niveau priorit√©
        self.action_templates = {
            "CRITIQUE": {
                "timeline": "0-2 semaines",
                "niveau_ressources": "Maximum",
                "suivi": "Quotidien",
                "indicateurs": ["R√©duction √©cart >80%", "Z√©ro incident"]
            },
            "URGENTE": {
                "timeline": "2-4 semaines", 
                "niveau_ressources": "√âlev√©",
                "suivi": "Hebdomadaire",
                "indicateurs": ["R√©duction √©cart >60%", "Conformit√© >90%"]
            },
            "√âLEV√âE": {
                "timeline": "1-2 mois",
                "niveau_ressources": "Mod√©r√©",
                "suivi": "Bi-hebdomadaire", 
                "indicateurs": ["R√©duction √©cart >40%", "Conformit√© >80%"]
            },
            "MOYENNE": {
                "timeline": "2-3 mois",
                "niveau_ressources": "Standard",
                "suivi": "Mensuel",
                "indicateurs": ["R√©duction √©cart >25%", "Conformit√© >70%"]
            }
        }
        
        logger.info(f"ü§ñ Agent {self.agent_id} ({self.agent_name}) initialis√©")
    
    async def process(self, data_an1: Dict, context: Dict = None) -> Dict:
        """
        Traitement principal: g√©n√©rer recommandations depuis zones aveugles AN1
        
        Args:
            data_an1: R√©sultats agent AN1 avec zones aveugles
            context: Contexte incident/secteur/organisation
            
        Returns:
            Dict avec plan d'action complet et recommandations
        """
        start_time = datetime.now()
        logger.info("üîÑ D√©marrage traitement Agent R1")
        
        try:
            # 1. Validation donn√©es AN1
            self._validate_an1_data(data_an1)
            logger.info("‚úÖ Validation donn√©es AN1 r√©ussie")
            
            # 2. Extraction zones aveugles prioritaires
            zones_aveugles = data_an1.get("ecarts_analysis", {}).get("zones_aveugles", [])
            priorite_globale = data_an1.get("summary", {}).get("priorite_intervention", "MOYENNE")
            
            # 3. G√©n√©ration recommandations par zone aveugle
            recommandations_detaillees = self._generate_detailed_recommendations(
                zones_aveugles, context
            )
            
            # 4. Cr√©ation plan d'action structur√©
            plan_action = self._create_action_plan(
                recommandations_detaillees, priorite_globale, context
            )
            
            # 5. Calcul budgets et ressources
            budget_analysis = self._calculate_budget_resources(
                recommandations_detaillees, context
            )
            
            # 6. G√©n√©ration timeline d'impl√©mentation
            implementation_timeline = self._generate_implementation_timeline(
                plan_action, context
            )
            
            # 7. M√©triques de succ√®s et KPIs
            success_metrics = self._define_success_metrics(
                zones_aveugles, recommandations_detaillees
            )
            
            # 8. Calcul performance et confiance
            performance_time = (datetime.now() - start_time).total_seconds()
            confidence_score = self._calculate_confidence_score(zones_aveugles, context)
            
            logger.info(f"üìä Performance R1: {performance_time:.2f}s, confidence: {confidence_score:.2f}")
            
            # 9. Construction r√©sultat final
            result = {
                "agent_info": {
                    "agent_id": self.agent_id,
                    "agent_name": self.agent_name, 
                    "version": self.version,
                    "timestamp": datetime.now().isoformat(),
                    "performance_time": performance_time,
                    "confidence_score": confidence_score
                },
                "recommandations_analysis": {
                    "zones_traitees": len(zones_aveugles),
                    "recommandations_generees": len(recommandations_detaillees),
                    "priorite_globale": priorite_globale,
                    "secteur_cible": context.get("secteur", "GENERAL") if context else "GENERAL"
                },
                "plan_action": plan_action,
                "recommandations_detaillees": recommandations_detaillees,
                "budget_analysis": budget_analysis,
                "implementation_timeline": implementation_timeline,
                "success_metrics": success_metrics,
                "business_impact": {
                    "roi_estime": budget_analysis.get("roi_estime", 0),
                    "cout_total": budget_analysis.get("cout_total", 0),
                    "economies_estimees": budget_analysis.get("economies_estimees", 0),
                    "payback_period": budget_analysis.get("payback_period", 0)
                }
            }
            
            logger.info(f"‚úÖ Agent R1 termin√© - {len(recommandations_detaillees)} recommandations g√©n√©r√©es")
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Erreur Agent R1: {str(e)}")
            return {"error": str(e), "agent_id": self.agent_id}
    
    def _validate_an1_data(self, data_an1: Dict):
        """Validation donn√©es AN1"""
        if not data_an1:
            raise ValueError("Donn√©es AN1 manquantes")
        
        required_fields = ["ecarts_analysis", "summary"]
        for field in required_fields:
            if field not in data_an1:
                raise ValueError(f"Champ AN1 manquant: {field}")
    
    def _generate_detailed_recommendations(self, zones_aveugles: List[Dict], context: Dict) -> List[Dict]:
        """G√©n√©ration recommandations d√©taill√©es par zone aveugle"""
        recommandations = []
        
        secteur = context.get("secteur", "GENERAL") if context else "GENERAL"
        taille_entreprise = context.get("taille_entreprise", "MOYENNE") if context else "MOYENNE"
        
        for i, zone in enumerate(zones_aveugles, 1):
            variable = zone.get("variable", "")
            ecart_pct = zone.get("pourcentage_ecart", 0)
            niveau_critique = zone.get("niveau_critique", "MOYENNE")
            
            # Base recommandations depuis DB
            base_reco = self.recommandations_db.get(variable, {})
            if not base_reco:
                continue
            
            # Adaptation sectorielle
            facteur_sectoriel = self.facteurs_sectoriels.get(secteur, {
                "multiplicateur_budget": 1.0,
                "duree_implementation": 1.0,
                "priorites_specifiques": [],
                "regulations": []
            })
            
            # Template action selon priorit√©
            action_template = self.action_templates.get(niveau_critique, self.action_templates["MOYENNE"])
            
            # Calcul budget adapt√©
            budget_base = base_reco.get("budget_unitaire", 200)
            budget_adapte = budget_base * facteur_sectoriel["multiplicateur_budget"]
            
            # Ajustement selon taille entreprise
            multiplicateur_taille = {
                "PME": 0.7,
                "MOYENNE": 1.0, 
                "GRANDE": 1.4
            }.get(taille_entreprise, 1.0)
            
            budget_final = budget_adapte * multiplicateur_taille
            
            # Construction recommandation d√©taill√©e
            recommendation = {
                "id": f"R1_{i:02d}",
                "variable_cible": variable,
                "zone_aveugle": zone,
                "priorite": niveau_critique,
                "ecart_a_corriger": ecart_pct,
                
                # Actions d√©taill√©es
                "formations": base_reco.get("formations", []),
                "procedures": base_reco.get("procedures", []),
                "actions_organisationnelles": base_reco.get("organisationnel", []),
                "equipements": base_reco.get("equipements", []),
                
                # Planification
                "timeline": action_template["timeline"],
                "niveau_ressources": action_template["niveau_ressources"],
                "suivi_frequence": action_template["suivi"],
                "indicateurs_succes": action_template["indicateurs"],
                
                # Budget et ressources
                "budget_estime": budget_final,
                "duree_formation": base_reco.get("duree_formation", 4),
                "personnels_impliques": self._estimate_personnel_count(variable, taille_entreprise),
                
                # Adaptation sectorielle
                "specificites_secteur": facteur_sectoriel["priorites_specifiques"],
                "regulations_applicables": facteur_sectoriel["regulations"],
                
                # M√©thode d'impl√©mentation
                "methode_implementation": self._generate_implementation_method(
                    variable, niveau_critique, secteur
                ),
                "risques_implementation": self._identify_implementation_risks(variable, secteur),
                "facteurs_succes": self._identify_success_factors(variable, niveau_critique)
            }
            
            recommandations.append(recommendation)
        
        return recommandations
    
    def _create_action_plan(self, recommandations: List[Dict], priorite_globale: str, context: Dict) -> Dict:
        """Cr√©ation plan d'action structur√©"""
        
        # Grouper par priorit√©
        actions_par_priorite = {}
        for reco in recommandations:
            priorite = reco["priorite"]
            if priorite not in actions_par_priorite:
                actions_par_priorite[priorite] = []
            actions_par_priorite[priorite].append(reco)
        
        # S√©quencement optimal
        sequence_optimale = self._optimize_action_sequence(recommandations)
        
        # Jalons cl√©s
        jalons = self._define_key_milestones(recommandations, context)
        
        plan = {
            "priorite_globale": priorite_globale,
            "nombre_actions": len(recommandations),
            "duree_totale_estimee": self._calculate_total_duration(recommandations),
            "actions_par_priorite": actions_par_priorite,
            "sequence_optimale": sequence_optimale,
            "jalons_cles": jalons,
            "coordination_requise": self._identify_coordination_needs(recommandations),
            "ressources_critiques": self._identify_critical_resources(recommandations)
        }
        
        return plan
    
    def _calculate_budget_resources(self, recommandations: List[Dict], context: Dict) -> Dict:
        """Calcul budgets et ressources requis"""
        
        cout_total = sum(reco["budget_estime"] for reco in recommandations)
        duree_formations = sum(reco["duree_formation"] for reco in recommandations)
        
        # Co√ªts indirects (temps personnel, logistique)
        cout_indirect = cout_total * 0.3  # 30% de co√ªts indirects
        cout_total_avec_indirect = cout_total + cout_indirect
        
        # Estimation √©conomies (r√©duction incidents)
        cout_incident_moyen = 75000  # Bas√© donn√©es CNESST
        reduction_risque_estimee = min(80, len(recommandations) * 15)  # Max 80%
        economies_estimees = cout_incident_moyen * (reduction_risque_estimee / 100)
        
        # ROI et payback
        roi_estime = ((economies_estimees - cout_total_avec_indirect) / cout_total_avec_indirect * 100) if cout_total_avec_indirect > 0 else 0
        payback_period = (cout_total_avec_indirect / economies_estimees * 12) if economies_estimees > 0 else 999  # mois
        
        return {
            "cout_direct": cout_total,
            "cout_indirect": cout_indirect, 
            "cout_total": cout_total_avec_indirect,
            "duree_formations_totale": duree_formations,
            "economies_estimees": economies_estimees,
            "roi_estime": roi_estime,
            "payback_period": min(payback_period, 60),  # Max 5 ans
            "budget_par_priorite": self._calculate_budget_by_priority(recommandations),
            "ressources_humaines": self._calculate_hr_resources(recommandations),
            "planning_budgetaire": self._create_budget_timeline(recommandations)
        }
    
    def _generate_implementation_timeline(self, plan_action: Dict, context: Dict) -> Dict:
        """G√©n√©ration timeline d'impl√©mentation d√©taill√©e"""
        
        today = datetime.now()
        timeline = {
            "date_debut": today.isoformat(),
            "duree_totale": plan_action["duree_totale_estimee"],
            "phases": []
        }
        
        # Phase 1: Pr√©paration (Semaine 1-2)
        phase_prep = {
            "nom": "Pr√©paration et mobilisation",
            "duree": "2 semaines",
            "date_debut": today,
            "date_fin": today + timedelta(weeks=2),
            "activites": [
                "Constitution √©quipe projet s√©curit√©",
                "Communication plan √† l'organisation",
                "Pr√©paration supports formation",
                "Planification d√©taill√©e interventions"
            ],
            "livrables": ["Plan projet d√©taill√©", "√âquipe mobilis√©e", "Supports pr√™ts"],
            "ressources": ["Chef projet SST", "RH", "Direction"]
        }
        timeline["phases"].append(phase_prep)
        
        # Phase 2: Actions critiques (Semaine 3-6)
        actions_critiques = [r for r in plan_action.get("actions_par_priorite", {}).get("CRITIQUE", [])]
        if actions_critiques:
            phase_critique = {
                "nom": "Actions critiques urgentes",
                "duree": "4 semaines",
                "date_debut": today + timedelta(weeks=2),
                "date_fin": today + timedelta(weeks=6),
                "activites": [f"Traiter {a['variable_cible']}" for a in actions_critiques],
                "livrables": ["Zones critiques corrig√©es", "Conformit√© >80%"],
                "ressources": ["Superviseurs", "Formateurs", "√âquipe terrain"]
            }
            timeline["phases"].append(phase_critique)
        
        # Phase 3: Actions √©lev√©es (Semaine 7-14)
        actions_elevees = [r for r in plan_action.get("actions_par_priorite", {}).get("√âLEV√âE", [])]
        if actions_elevees:
            phase_elevee = {
                "nom": "Renforcement et consolidation",
                "duree": "8 semaines", 
                "date_debut": today + timedelta(weeks=6),
                "date_fin": today + timedelta(weeks=14),
                "activites": [f"Renforcer {a['variable_cible']}" for a in actions_elevees],
                "livrables": ["Culture s√©curit√© renforc√©e", "Proc√©dures optimis√©es"],
                "ressources": ["Coaches s√©curit√©", "R√©f√©rents terrain"]
            }
            timeline["phases"].append(phase_elevee)
        
        # Phase 4: Suivi et am√©lioration continue (Semaine 15+)
        phase_suivi = {
            "nom": "Suivi et am√©lioration continue",
            "duree": "Continu",
            "date_debut": today + timedelta(weeks=14),
            "date_fin": None,
            "activites": [
                "Mesure indicateurs de succ√®s",
                "Ajustements selon retours terrain",
                "Reconnaissance r√©ussites",
                "Planification cycles suivants"
            ],
            "livrables": ["Tableau bord mensuel", "Plan am√©lioration continue"],
            "ressources": ["√âquipe SST", "Data analyst"]
        }
        timeline["phases"].append(phase_suivi)
        
        return timeline
    
    def _define_success_metrics(self, zones_aveugles: List[Dict], recommandations: List[Dict]) -> Dict:
        """D√©finition m√©triques de succ√®s et KPIs"""
        
        metrics = {
            "indicateurs_principaux": [],
            "objectifs_court_terme": {},  # 1-3 mois
            "objectifs_moyen_terme": {},  # 3-12 mois  
            "objectifs_long_terme": {},   # 12+ mois
            "frequence_mesure": "Mensuel",
            "responsable_suivi": "Responsable SST + Direction"
        }
        
        # Indicateurs par zone aveugle
        for zone in zones_aveugles:
            variable = zone["variable"]
            ecart_initial = zone["pourcentage_ecart"]
            
            # Objectifs de r√©duction d'√©cart
            objectif_court = max(5, ecart_initial * 0.4)      # R√©duire de 60%
            objectif_moyen = max(3, ecart_initial * 0.2)      # R√©duire de 80%
            objectif_long = max(1, ecart_initial * 0.1)       # R√©duire de 90%
            
            indicateur = {
                "variable": variable,
                "valeur_initiale": ecart_initial,
                "objectif_court_terme": objectif_court,
                "objectif_moyen_terme": objectif_moyen, 
                "objectif_long_terme": objectif_long,
                "unite": "% √©cart",
                "methode_mesure": "Audit SafetyAgentic mensuel"
            }
            metrics["indicateurs_principaux"].append(indicateur)
        
        # M√©triques globales
        metrics["indicateurs_globaux"] = {
            "score_culture_global": {
                "objectif_court": 80,
                "objectif_moyen": 85,
                "objectif_long": 90,
                "unite": "/100"
            },
            "taux_incidents": {
                "objectif_court": -30,  # R√©duction 30%
                "objectif_moyen": -50,  # R√©duction 50%
                "objectif_long": -70,   # R√©duction 70%
                "unite": "% variation"
            },
            "conformite_epi": {
                "objectif_court": 85,
                "objectif_moyen": 90,
                "objectif_long": 95,
                "unite": "% conformit√©"
            }
        }
        
        return metrics
    
    # M√©thodes utilitaires
    def _estimate_personnel_count(self, variable: str, taille_entreprise: str) -> int:
        """Estimation nombre personnes impliqu√©es"""
        base_counts = {
            "PME": {"usage_epi": 15, "supervision_directe": 5, "formation_securite": 12},
            "MOYENNE": {"usage_epi": 45, "supervision_directe": 12, "formation_securite": 35},
            "GRANDE": {"usage_epi": 120, "supervision_directe": 25, "formation_securite": 80}
        }
        return base_counts.get(taille_entreprise, {}).get(variable, 20)
    
    def _generate_implementation_method(self, variable: str, priorite: str, secteur: str) -> str:
        """G√©n√©ration m√©thode d'impl√©mentation sp√©cifique"""
        methods = {
            "usage_epi": f"Formation pratique + contr√¥les quotidiens superviseurs + syst√®me sanctions progressives",
            "supervision_directe": f"Formation leadership + rondes obligatoires + reporting hebdomadaire",
            "formation_securite": f"Mise √† jour contenus secteur {secteur} + certification + √©valuation pratique"
        }
        return methods.get(variable, "Formation + proc√©dures + suivi mensuel")
    
    def _identify_implementation_risks(self, variable: str, secteur: str) -> List[str]:
        """Identification risques d'impl√©mentation"""
        return [
            "R√©sistance au changement √©quipes terrain",
            "Manque de temps pour formations durant production",
            "Co√ªts impr√©vus √©quipements/ressources",
            "Turnover personnel form√©"
        ]
    
    def _identify_success_factors(self, variable: str, priorite: str) -> List[str]:
        """Identification facteurs cl√©s de succ√®s"""
        return [
            "Engagement visible direction et management",
            "Communication claire b√©n√©fices s√©curit√©",
            "Formation adapt√©e aux r√©alit√©s terrain",
            "Syst√®me reconnaissance/r√©compenses",
            "Suivi r√©gulier et ajustements"
        ]
    
    def _optimize_action_sequence(self, recommandations: List[Dict]) -> List[str]:
        """Optimisation s√©quence d'actions"""
        # Trier par priorit√© puis par d√©pendances
        sequence = []
        priorites = ["CRITIQUE", "URGENTE", "√âLEV√âE", "MOYENNE"]
        
        for priorite in priorites:
            reco_priorite = [r for r in recommandations if r["priorite"] == priorite]
            sequence.extend([r["id"] for r in reco_priorite])
        
        return sequence
    
    def _define_key_milestones(self, recommandations: List[Dict], context: Dict) -> List[Dict]:
        """D√©finition jalons cl√©s"""
        return [
            {"nom": "Formations critiques termin√©es", "semaine": 4},
            {"nom": "Proc√©dures mises √† jour", "semaine": 8}, 
            {"nom": "Premi√®re √©valuation SafetyAgentic", "semaine": 12},
            {"nom": "Objectifs court terme atteints", "semaine": 16}
        ]
    
    def _identify_coordination_needs(self, recommandations: List[Dict]) -> List[str]:
        """Identification besoins de coordination"""
        return [
            "Coordination formation/production pour minimiser impact",
            "Synchronisation changements proc√©dures entre √©quipes", 
            "Alignement budgets RH/SST/Production",
            "Communication coh√©rente vers toutes parties prenantes"
        ]
    
    def _identify_critical_resources(self, recommandations: List[Dict]) -> List[str]:
        """Identification ressources critiques"""
        return [
            "Formateurs SST qualifi√©s secteur",
            "Temps superviseurs pour formation",
            "Budget √©quipements EPI/s√©curit√©",
            "Support IT pour digitalisation"
        ]
    
    def _calculate_budget_by_priority(self, recommandations: List[Dict]) -> Dict:
        """Calcul budget par priorit√©"""
        budget_priorite = {}
        for reco in recommandations:
            priorite = reco["priorite"]
            budget = reco["budget_estime"]
            if priorite not in budget_priorite:
                budget_priorite[priorite] = 0
            budget_priorite[priorite] += budget
        return budget_priorite
    
    def _calculate_hr_resources(self, recommandations: List[Dict]) -> Dict:
        """Calcul ressources humaines requises"""
        total_personnel = sum(reco["personnels_impliques"] for reco in recommandations)
        total_heures_formation = sum(
            reco["duree_formation"] * reco["personnels_impliques"] 
            for reco in recommandations
        )
        
        return {
            "personnel_total_implique": total_personnel,
            "heures_formation_totales": total_heures_formation,
            "jours_formation_equivalents": total_heures_formation / 8,
            "formateurs_requis": max(1, total_heures_formation // 40),  # 40h par formateur
            "coordinateurs_requis": max(1, len(recommandations) // 3)   # 1 coord pour 3 actions
        }
    
    def _create_budget_timeline(self, recommandations: List[Dict]) -> Dict:
        """Cr√©ation planning budg√©taire"""
        today = datetime.now()
        planning = {}
        
        # R√©partition par trimestre
        for i, trimestre in enumerate(["T1", "T2", "T3", "T4"]):
            budget_trimestre = 0
            actions_trimestre = []
            
            for reco in recommandations:
                # Simplification: r√©partir selon priorit√©
                if reco["priorite"] in ["CRITIQUE", "URGENTE"] and i == 0:
                    budget_trimestre += reco["budget_estime"]
                    actions_trimestre.append(reco["id"])
                elif reco["priorite"] == "√âLEV√âE" and i == 1:
                    budget_trimestre += reco["budget_estime"]
                    actions_trimestre.append(reco["id"])
                elif reco["priorite"] == "MOYENNE" and i in [2, 3]:
                    budget_trimestre += reco["budget_estime"] / 2
                    actions_trimestre.append(reco["id"])
            
            planning[trimestre] = {
                "budget": budget_trimestre,
                "actions": actions_trimestre,
                "periode": f"{today + timedelta(weeks=i*13):%B %Y}"
            }
        
        return planning
    
    def _calculate_total_duration(self, recommandations: List[Dict]) -> str:
        """Calcul dur√©e totale estim√©e"""
        durees_priorite = {
            "CRITIQUE": 4,   # semaines
            "URGENTE": 6,
            "√âLEV√âE": 12,
            "MOYENNE": 20
        }
        
        duree_max = 0
        for reco in recommandations:
            duree_priorite = durees_priorite.get(reco["priorite"], 12)
            duree_max = max(duree_max, duree_priorite)
        
        return f"{duree_max} semaines"
    
    def _calculate_confidence_score(self, zones_aveugles: List[Dict], context: Dict) -> float:
        """Calcul score confiance recommandations"""
        if not zones_aveugles:
            return 0.5
        
        # Facteurs de confiance
        nombre_zones = len(zones_aveugles)
        facteur_nombre = min(1.0, nombre_zones / 5)  # Optimal √† 5 zones
        
        # Qualit√© des donn√©es contextuelles
        facteur_contexte = 0.8 if context and context.get("secteur") else 0.6
        
        # Coh√©rence des √©carts
        ecarts = [z.get("pourcentage_ecart", 0) for z in zones_aveugles]
        coherence = 1.0 - (np.std(ecarts) / 100) if ecarts else 0.5
        
        confidence = (facteur_nombre * 0.3) + (facteur_contexte * 0.4) + (coherence * 0.3)
        return max(0.3, min(0.95, confidence))


# Test fonctionnel R1
async def test_r1_generateur_recommandations():
    """Test fonctionnel Agent R1 avec zones aveugles AN1"""
    
    print("üß™ TEST AGENT R1 - G√âN√âRATEUR RECOMMANDATIONS")
    print("=" * 50)
    
    # Donn√©es simul√©es AN1 (zones aveugles d√©tect√©es)
    data_an1_with_blind_spots = {
        "ecarts_analysis": {
            "zones_aveugles": [
                {
                    "variable": "supervision_directe",
                    "pourcentage_ecart": 55.6,
                    "niveau_critique": "CRITIQUE",
                    "type_ecart": "surestimation",
                    "score_autoeval": 7.5,
                    "score_terrain": 3.5,
                    "impact_potentiel": "CRITIQUE - Risque incident majeur"
                },
                {
                    "variable": "usage_epi",
                    "pourcentage_ecart": 43.5,
                    "niveau_critique": "√âLEV√âE",
                    "type_ecart": "surestimation", 
                    "score_autoeval": 8.5,
                    "score_terrain": 4.8,
                    "impact_potentiel": "√âLEV√â - Intervention urgente requise"
                },
                {
                    "variable": "formation_securite",
                    "pourcentage_ecart": 28.3,
                    "niveau_critique": "√âLEV√âE",
                    "type_ecart": "surestimation",
                    "score_autoeval": 7.2,
                    "score_terrain": 5.8,
                    "impact_potentiel": "MOD√âR√â - Surveillance renforc√©e"
                }
            ],
            "nombre_ecarts_critiques": 3
        },
        "summary": {
            "ecart_moyen": 42.5,
            "variables_critiques": 3,
            "priorite_intervention": "CRITIQUE"
        }
    }
    
    # Contexte r√©aliste construction
    context_construction = {
        "secteur": "CONSTRUCTION",
        "type_incident": "CHUTE_HAUTEUR",
        "taille_entreprise": "MOYENNE",
        "nombre_employes": 85,
        "budget_sst_annuel": 125000,
        "certification_existante": "ISO45001"
    }
    
    # Initialiser et tester R1
    agent_r1 = R1GenerateurRecommandations()
    result = await agent_r1.process(data_an1_with_blind_spots, context_construction)
    
    # Affichage r√©sultats
    print("üìä R√âSULTATS AGENT R1:")
    print("=" * 25)
    print(f"‚úÖ Score confiance: {result['agent_info']['confidence_score']:.3f}")
    print(f"üìä Zones trait√©es: {result['recommandations_analysis']['zones_traitees']}")
    print(f"üí° Recommandations g√©n√©r√©es: {result['recommandations_analysis']['recommandations_generees']}")
    print(f"üéØ Priorit√© globale: {result['recommandations_analysis']['priorite_globale']}")
    
    # Plan d'action
    plan_action = result['plan_action']
    print(f"\nüìã PLAN D'ACTION:")
    print(f"  ‚Ä¢ Dur√©e totale: {plan_action['duree_totale_estimee']}")
    print(f"  ‚Ä¢ Actions par priorit√©: {len(plan_action['actions_par_priorite'])}")
    print(f"  ‚Ä¢ S√©quence optimis√©e: {len(plan_action['sequence_optimale'])} √©tapes")
    
    # Budget analysis
    budget = result['budget_analysis']
    print(f"\nüí∞ ANALYSE BUDG√âTAIRE:")
    print(f"  ‚Ä¢ Co√ªt direct: {budget['cout_direct']:,.0f}$")
    print(f"  ‚Ä¢ Co√ªt total: {budget['cout_total']:,.0f}$")
    print(f"  ‚Ä¢ √âconomies estim√©es: {budget['economies_estimees']:,.0f}$")
    print(f"  ‚Ä¢ ROI estim√©: {budget['roi_estime']:.1f}%")
    print(f"  ‚Ä¢ Payback: {budget['payback_period']:.1f} mois")
    
    # Recommandations d√©taill√©es (top 2)
    print(f"\nüí° TOP RECOMMANDATIONS:")
    for i, reco in enumerate(result['recommandations_detaillees'][:2], 1):
        print(f"  {i}. {reco['variable_cible']} (Priorit√©: {reco['priorite']})")
        print(f"     üìä √âcart √† corriger: {reco['ecart_a_corriger']:.1f}%")
        print(f"     ‚è±Ô∏è Timeline: {reco['timeline']}")
        print(f"     üí∞ Budget: {reco['budget_estime']:,.0f}$")
        print(f"     üéØ Formations: {len(reco['formations'])} modules")
        
        # Actions principales
        if reco['formations']:
            print(f"     üìö Formation cl√©: {reco['formations'][0]}")
        if reco['procedures']:
            print(f"     üìã Proc√©dure cl√©: {reco['procedures'][0]}")
    
    # Timeline d'impl√©mentation
    timeline = result['implementation_timeline']
    print(f"\nüìÖ TIMELINE IMPL√âMENTATION:")
    for phase in timeline['phases'][:3]:  # Top 3 phases
        print(f"  ‚Ä¢ {phase['nom']}: {phase['duree']}")
        print(f"    ‚îî‚îÄ‚îÄ {len(phase['activites'])} activit√©s pr√©vues")
    
    # M√©triques de succ√®s
    metrics = result['success_metrics']
    print(f"\nüìà M√âTRIQUES DE SUCC√àS:")
    for indicateur in metrics['indicateurs_principaux'][:2]:
        print(f"  ‚Ä¢ {indicateur['variable']}:")
        print(f"    Initial: {indicateur['valeur_initiale']:.1f}% ‚Üí Objectif: {indicateur['objectif_court_terme']:.1f}%")
    
    # Impact business
    business_impact = result['business_impact']
    print(f"\nüíº IMPACT BUSINESS:")
    print(f"  ‚Ä¢ ROI: {business_impact['roi_estime']:.1f}%")
    print(f"  ‚Ä¢ √âconomies: {business_impact['economies_estimees']:,.0f}$")
    print(f"  ‚Ä¢ Investissement: {business_impact['cout_total']:,.0f}$")
    print(f"  ‚Ä¢ Retour sur investissement: {business_impact['payback_period']:.1f} mois")
    
    print(f"\n‚úÖ Test Agent R1 termin√© avec succ√®s!")
    print(f"‚è±Ô∏è Performance: {result['agent_info']['performance_time']:.3f}s")
    return result

# Ex√©cution test si script appel√© directement
if __name__ == "__main__":
    import asyncio
    asyncio.run(test_r1_generateur_recommandations())